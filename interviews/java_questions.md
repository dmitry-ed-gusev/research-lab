Как вывести из строя java-машину?

Вот несколько методов, которые помогут вам начать:
1. Постарайтесь выделить как можно больше памяти. Оперативная память
не бесконечна - если ОЗУ больше невозможно выделять, ваш процесс
завершится неудачей.
2. Попробуйте записывать данные на свой жесткий диск, пока он не заполнится.
Та же проблема, что и с оперативной памятью: хотя объем постоянной
памяти больше ОЗУ, дисковое пространство тоже не безгранично.
3. Постарайтесь открыть как можно больше файлов. Известно ли вам максимальное
количество файловых дескрипторов для вашей среды?
4. Постарайтесь создать как можно больше потоков. В системе Linux если вы
посмотрите на /proc/sys/kernel/pid_max, то увидите, сколько процессов
можно запустить в вашей системе. Как много потоков вам разрешено создавать
в своей системе?
95 https://t.me/javalib
5. Попробуйте изменить ваши файлы .class в файловой системе, и текущий
запуск вашего приложения будет последним!
6. Попробуйте найти собственный идентификатор процесса, а затем попытайтесь
уничтожить его с помощью Runtime . ехес (например, вызвав kill
-9 для вашего идентификатора процесса).
7. Попробуйте создать во время выполнения класс, который вызывает только
System.exit, динамически загрузите его через загрузчик классов, а затем
вызовите его.
8. Постарайтесь открыть как можно больше подключений к сокетам. В системе
Unix максимальное количество таких подключений равняется максимальному
количеству файловых дескрипторов (обычно 2048). Сколько из
них доступно там, где запущено ваше приложение?
9. Попробуйте взломать свою систему. Загрузите эксплойт с помощью кода
или wget. Запустите эксплойт, а затем вызовите shutdown -h от имени
root в системе Unix или shutdown / s от имени администратора в системе
Windows.
10. Попробуйте «прыгнуть без страховочной сетки». Частично безопасность
Java обеспечивается ее языковым дизайном, а частично - проверкой
байт-кода в вашей JVM. Запустите свою JVM с флагом -noverify или
-Xverify:none, которые отключают любую проверку байт-кода и записывают
то, что в противном случае было бы запрещено запускать.
11. Попробуйте использовать Unsafe. Этот класс backdoor используется для
получения доступа к низкоуровневым средствам, таким как управление
памятью. Вот вам и синтаксис Java, вот вам и безопасность С!
12. Попробуйте пройти нативным путем. Напишите какой-нибудь машин-
ный код. Вот вам и синтаксис С, вот вам и безопасность С!

----------------------------------------------------------------------------------------------------------

Типы ссылок:

Все статические объекты живут вечно. Это означает, что все их атрибуты,
на которые они ссылаются, также будут жить вечно.

Чтобы помочь GC собирать нежелательные объекты, применяйте специальные
типы ссылок, соответствующие классы которых можно найти в java. lang. ref:
Wеаk-ссылка Не считается ссылкой для очистки. Например, можно
использовать WeakHashMap (https://oreil./y/6PGRЛ, работающую
как HashMap (https://oreil.ly/8_6ss), но использующую wеаk-ссылку.
Таким образом, если map содержит объект, на который есть
только ссылка в самом map, его можно удалить.
Sоft-ссылка К такой ссылке GC относится с уважением и удаляет объект
в зависимости от потребности в памяти.
Phantom-ccылкa Всегда возвращает null. Ссылка на самом деле не указывает
на объект. Используется для очистки объектов перед
извлечением объекта, который его связывает.

Hard - обычная ссылка на обьект

----------------------------------------------------------------------------------------------------------

Java GC + Memory Model

Java делит свою память на два сегмента:
Неар Экземпляры, переменные ... ваши данные
Nonheap/perm Код, метаданные ... для JVM
Если мы хотим разобраться с памятью в Java, нужно сосредоточиться на Неар
(куче). Она делится на два поколения, которые классифицируют по продолжительности
жизни: молодое и старое. Молодое поколение (оно же детское)
содержит недолговечные объекты. Старое поколение содержит структуры,
которые сохранились дольше.
Молодое поколение разделено на две части:
Eden
Survivor
Где создаются объекты
Промежуточное, неопределенное состояние, через которое
экземпляр будет переходить из молодого в старое поколение
Сборщик мусора
Сборщик мусора (GC) - это система, очищающая память. Существуют разные
реализации, но в целом он выполняет две задачи:
Minor-cбopкa
Маjоr-сборка
Просматривает молодое поколение
Просматривает всю память, молодую и старую
GC выполняется одновременно с обычным выполнением приложения.
При каждом выполнении GC все запущенные потоки становятся на паузу
(как правило, измеряемую миллисекундами).

